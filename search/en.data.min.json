[{"id":0,"href":"/TracerTutorial/usage/annotations/","title":"Annotations","parent":"Usage","content":"Click them to expand. Root ↕ Each class with @Tracer.Root is considered as the trace start point, followed by interior module-visible elements.\nYour browser doesn’t support embedded videos, but don’t worry, you can download it and watch it with your favorite video player! An interior element wouldn’t be traced insides if it’s nullable or its type class is with @Tracer. Root. As a qualified design, Tracer.Root classes are independent and avoid being explored too insides. Nodes ↕ Now we add one bedroom and some inner objects as below. Annotate Bedroom with Tracer.Nodes(House::class), which makes Bedroom’s interior elements shared and connect with those inside House but outside Bedroom.\nYour browser doesn't support embedded videos, but don't worry, you can download it and watch it with your favorite video player! An interior element wouldn’t be traced insides if its type class is with @Tracer.Nodes. If Living room needs the quilt from master bedroom’sBed, use _Bedroom_House_masterBedroom._Quilt. Tip ↕ Tracer.Tip represents the trace end, meaning elements of annotated classes wouldn’t be traced insides. Furthermore, classes are considered as Tracer.Tip by default if they are foreign (from other modules, generated code, or Java files), or with rebuilt symbols (type parameters, value parameters in the constructor, abstract or open). Like Tracer.Root classes, they should avoid being exploring too insides if qualified.\nOmit ↕ Properties and super types with @Tracer.Omit would be omitted, which is generally used with some unsupported new syntaxes, e.g. T \u0026 Any before ksp 1.8.0-1.0.9(exclusive), and context receiver. Super type trace rules are later explained on page Details. Your browser doesn’t support embedded videos, but don’t worry, you can download it and watch it with your favorite video player! ","description":"Click them to expand. Root ↕ Each class with @Tracer.Root is considered as the trace start point, followed by interior module-visible elements.\nYour browser doesn’t support embedded videos, but don’t worry, you can download it and watch it with your favorite video player! An interior element wouldn’t be traced insides if it’s nullable or its type class is with @Tracer. Root. As a qualified design, Tracer.Root classes are independent and avoid being explored too insides."},{"id":1,"href":"/TracerTutorial/extensions/traditional-android/","title":"Traditional android","parent":"Extensions","content":"See github repo if you need.\nSetup libraryVariants.all { def variantName = name sourceSets { getByName(\u0026#34;main\u0026#34;) { java.srcDir(file(\u0026#34;$buildDir/generated/ksp/$variantName/kotlin\u0026#34;)) } } } 如果上述方式遭遇小几率失败，需要换成以下方式，如果有其他 buildDir 则手动指定\nkotlin { sourceSets.debug.kotlin.srcDirs += \u0026#39;build/generated/ksp/debug/kotlin\u0026#39; sourceSets.release.kotlin.srcDirs += \u0026#39;build/generated/ksp/release/kotlin\u0026#39; } ","description":"See github repo if you need.\nSetup libraryVariants.all { def variantName = name sourceSets { getByName(\u0026#34;main\u0026#34;) { java.srcDir(file(\u0026#34;$buildDir/generated/ksp/$variantName/kotlin\u0026#34;)) } } } 如果上述方式遭遇小几率失败，需要换成以下方式，如果有其他 buildDir 则手动指定\nkotlin { sourceSets.debug.kotlin.srcDirs += \u0026#39;build/generated/ksp/debug/kotlin\u0026#39; sourceSets.release.kotlin.srcDirs += \u0026#39;build/generated/ksp/release/kotlin\u0026#39; } "},{"id":2,"href":"/TracerTutorial/usage/naming-rules/","title":"Property naming rules","parent":"Usage","content":" Type symbols suspend (MutableMap\u0026lt;in String, out CharSequence\u0026gt;) -\u0026gt; Comparable\u0026lt;*\u0026gt;? would be converted to ⍒❨MutableMap‹↑String，↓CharSequence›❩-›Comparable‹✶›？. Unfortunately, android forbids most original common symbols in property names, making me choose these substitutes ⍒ ❨ ❩ -› ‹ › ？ ， ✶ ↑ ↓.\nWildcard * would be tried converting to its bound with the covariance if needed, like from from Array\u0026lt;*\u0026gt; to Array‹↓Any？› and List\u0026lt;*\u0026gt; to List‹Any？›. Comparable\u0026lt;*\u0026gt; is not convertible because its source code is Comparable\u0026lt;in T\u0026gt;. Generic type Single bound Multiple bounds\nCovariance(↓) may be needed. Position qualifier __ : beginning with double _ tells it\u0026rsquo;s from outside. See Annotations.Nodes if you forget other code. ˚: as shown in the image above, ˚House means that House is the nearest owner with @Tracer.Root or Tracer.Nodes of that WifiRouter. I consider this as level tag. Same types would be traced with owner name or property name further to be distinguished. There would be by inside if one same type is super and from the trace start point. nullability suspend generic name and variance are omitted in type equality comparison to hint better. Elements of common types or common types embedded in common containers are always traced with owner name and property name to be clear like _String_X_name.\nCommon types String Any Short ShortArray UShort UShortArray Int IntArray UInt UIntArray Long LongArray ULong ULongArray Byte ByteArray UByte UByteArray Float FloatArray Double DoubleArray Boolean BooleanArray Char CharArray\nCommon containers\nPair Triple Array Sequence Iterable Collection List Set Map MutableIterable MutableCollection MutableList MutableSet MutableMap\nExample ","description":"Type symbols suspend (MutableMap\u0026lt;in String, out CharSequence\u0026gt;) -\u0026gt; Comparable\u0026lt;*\u0026gt;? would be converted to ⍒❨MutableMap‹↑String，↓CharSequence›❩-›Comparable‹✶›？. Unfortunately, android forbids most original common symbols in property names, making me choose these substitutes ⍒ ❨ ❩ -› ‹ › ？ ， ✶ ↑ ↓.\nWildcard * would be tried converting to its bound with the covariance if needed, like from from Array\u0026lt;*\u0026gt; to Array‹↓Any？› and List\u0026lt;*\u0026gt; to List‹Any？›. Comparable\u0026lt;*\u0026gt; is not convertible because its source code is Comparable\u0026lt;in T\u0026gt;."},{"id":3,"href":"/TracerTutorial/setup/","title":"Setup","parent":"","content":"Configure your build.gradle as below.\nKsp plugin plugins{ // Assuming your kotlin version is `1.7.21`, here uses the latest ksp plugin version beginning // with `1.7.21` (\u0026#39;1.7.21-1.0.8\u0026#39;). id \u0026#39;com.google.devtools.ksp\u0026#39; version \u0026#39;1.7.21-1.0.8\u0026#39; } Source sets Skip this step if your ksp plugin version is \u0026lsquo;1.8.0-1.0.9\u0026rsquo; or higher.\nThis part is different if you are using IntelliJ IDEA and KSP in a Gradle plugin. (See ksp quickstart)\n// Omissible if your ksp plugin version is \u0026#39;1.8.0-1.0.9\u0026#39; or higher. kotlin.sourceSets { main.kotlin.srcDirs += \u0026#34;$buildDir/generated/ksp/main/kotlin\u0026#34; test.kotlin.srcDirs += \u0026#34;$buildDir/generated/ksp/test/kotlin\u0026#34; } Tracer Add this part directly, rather than insert messily.\n//region tracer // options ksp{ // arg(\u0026#34;tracer.allInternallyGenerated\u0026#34;, \u0026#34;\u0026#34;) // arg(\u0026#34;tracer.fullNameProperties\u0026#34;, \u0026#34;\u0026#34;) } tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach { kotlinOptions.freeCompilerArgs += \u0026#39;-Xcontext-receivers\u0026#39; } dependencies { // Keep this version latest with the prefix lower than your kotlin version(inclusive). ksp \u0026#39;io.github.apollokwok:tracer-common-compiler:1.7.20-1.2.0\u0026#39; // Keep this version latest but lower than the version above(inclusive). implementation \u0026#39;io.github.apollokwok:tracer-common-annotations:1.7.20-1.2.0\u0026#39; } //endregion ","description":"Configure your build.gradle as below.\nKsp plugin plugins{ // Assuming your kotlin version is `1.7.21`, here uses the latest ksp plugin version beginning // with `1.7.21` (\u0026#39;1.7.21-1.0.8\u0026#39;). id \u0026#39;com.google.devtools.ksp\u0026#39; version \u0026#39;1.7.21-1.0.8\u0026#39; } Source sets Skip this step if your ksp plugin version is \u0026lsquo;1.8.0-1.0.9\u0026rsquo; or higher.\nThis part is different if you are using IntelliJ IDEA and KSP in a Gradle plugin. (See ksp quickstart)\n// Omissible if your ksp plugin version is \u0026#39;1."},{"id":4,"href":"/TracerTutorial/usage/details/","title":"Details","parent":"Usage","content":" Partial traceable super types Built times of traced element types would be displayed Type aliases are always converted to its actual types Options You could enable these in build.gradle.\nksp{ arg(\u0026#34;tracer.allInternallyGenerated\u0026#34;, \u0026#34;\u0026#34;) arg(\u0026#34;tracer.fullNameProperties\u0026#34;, \u0026#34;\u0026#34;) } Your browser doesn't support embedded videos, but don't worry, you can download it and watch it with your favorite video player! Var Source code\n@Tracer.Root class VarSample : VarSampleTracer{ var foo: Foo = TODO() val baz = Baz() override val _VarSample: VarSample = this } Generated code\npublic var VarSampleTracer._Foo inline get() = _VarSample.foo as Foo inline set(value){ _VarSample.foo = value } Reference sample\ncontext (VarSampleTracer) class Baz{ private var foo: Foo get() = _Foo set(value) { _Foo = value } } Expected reference after authoritative support.\ncontext (VarSampleTracer) class Baz{ private var foo: Foo by this@VarSampleTracer::_Foo } Abstract / open class elements Elements inside abstract and open classes are all traced with level tags (_˚NonFinalSample in this case) to be distinguished in subclasses.\n","description":"Partial traceable super types Built times of traced element types would be displayed Type aliases are always converted to its actual types Options You could enable these in build.gradle.\nksp{ arg(\u0026#34;tracer.allInternallyGenerated\u0026#34;, \u0026#34;\u0026#34;) arg(\u0026#34;tracer.fullNameProperties\u0026#34;, \u0026#34;\u0026#34;) } Your browser doesn't support embedded videos, but don't worry, you can download it and watch it with your favorite video player! Var Source code\n@Tracer.Root class VarSample : VarSampleTracer{ var foo: Foo = TODO() val baz = Baz() override val _VarSample: VarSample = this } Generated code"},{"id":5,"href":"/TracerTutorial/usage/","title":"Usage","parent":"","content":"","description":""},{"id":6,"href":"/TracerTutorial/usage/notes/","title":"Notes","parent":"Usage","content":" Common Kotlin Native and Kotlin JS are not supported. Because they lack context receiver which is essential in this tool.\nAlways inject like prival val x get() = _X. Just obey it which is confusing to tyros but automatically understandable when you get familiar.\nTracer is compatible with ksp 1.7.0-1.0.6 at least. Although mostly it works well with ksp, you\u0026rsquo;d better try to make your ksp plugin in a high stable version, since ksp api is not stable and many bugs are fixed every version.\nJava files are forbidden to use Tracer, because I don\u0026rsquo;t want to spend time analyzing those outdated things. But it\u0026rsquo;s absolutely safe to reference java classes and functions in kotlin files. Rare Problems below are so unusual that you could read it later or when you get puzzled. Few generated types fail code inspection, mostly because of the imperfect authoritative type. Use another source type or annotate them with Tracer.Omit. Unfortunately, I forget those rare cases which should be displayed here. * in alias types are all shifted first and then converted, which, however, may be inaccurate.\nFor source code interface A\u0026lt;T: Iterable\u0026lt;String\u0026gt;\u0026gt; interface B\u0026lt;T: List\u0026lt;CharSequence\u0026gt;\u0026gt; typealias MyTypeAlias\u0026lt;T\u0026gt; = Pair\u0026lt;A\u0026lt;T\u0026gt;, B\u0026lt;T\u0026gt;\u0026gt; The real bound is List\u0026lt;String\u0026gt;, which is only one of those difficult cases. With Tracer, MyTypeAlias\u0026lt;*\u0026gt; is converted to Pair\u0026lt;A\u0026lt;*\u0026gt;, B\u0026lt;*\u0026gt;\u0026gt; first, and Pair\u0026lt;A\u0026lt;out Iterable\u0026lt;String\u0026gt;\u0026gt;, B\u0026lt;out List\u0026lt;CharSequence\u0026gt;\u0026gt;\u0026gt; next. Super types with compound args are not limited.\nSource Code\ninterface Sub\u0026lt;T\u0026gt; : Super\u0026lt;T\u0026gt; where T: Serializable, T: CharSequence interface Super\u0026lt;T\u0026gt; @Tracer.Root class CompoundTypeSample\u0026lt;T\u0026gt; : CompoundTypeSampleTracer where T: CharSequence, T: Serializable { val sub: Sub\u0026lt;T\u0026gt; = TODO() override val _CompoundTypeSample: CompoundTypeSample\u0026lt;*\u0026gt; = this } Generated code\npublic val CompoundTypeSampleTracer.`_Sub‹↓‹Serializable，CharSequence››` inline get() = `_CompoundTypeSample`.`sub` as Sub\u0026lt;*\u0026gt; public val CompoundTypeSampleTracer.`_Super‹↓‹Serializable，CharSequence››` inline get() = `_CompoundTypeSample`.`sub` as Super\u0026lt;*\u0026gt; * in Sub\u0026lt;*\u0026gt; has two bounds, which, however, can\u0026rsquo;t be expressed in Super\u0026lt;*\u0026gt;.\n","description":"Common Kotlin Native and Kotlin JS are not supported. Because they lack context receiver which is essential in this tool.\nAlways inject like prival val x get() = _X. Just obey it which is confusing to tyros but automatically understandable when you get familiar.\nTracer is compatible with ksp 1.7.0-1.0.6 at least. Although mostly it works well with ksp, you\u0026rsquo;d better try to make your ksp plugin in a high stable version, since ksp api is not stable and many bugs are fixed every version."},{"id":7,"href":"/TracerTutorial/expectedOptimization/","title":"Expected optimization","parent":"","content":"Tracer is not perfect, but can be optimized much if the IDE and Kotlin plugin cooperate.\n1, Too many hints when you input _X. in a big project. (after the visibility, of functions with context receivers, is fixed -\u0026gt; new generated tracer property would replace the receiver with context receiver. Then there wouldn\u0026rsquo;t be redundant hints.)\n2, names may change with the structure.\n-\u0026gt; 新的变更名字模式，实际值为 contractedName_packageName(_levelTag)_containerName_propertyName。 根据当前的实际需要来显示。且后台给每个 context 分配出一套提示\n3, 针对 property 重写问题，如\n@Tracer.Root class X : XTracer{ abstract val j: J } @Tracer.Root class XImpl : X(), XImplTracer{ override val j: J = J() } 结合2，如果有重写，则父类相应的 val XTracer.j inline get() = ... 不对 XImplTracer 可见\n4, Implement tracer interfaces automatically.\n5, Override and solve the conflict automatically.\n6, 生成结构图\n7, Let android lift restriction on property names.\nincremental processing after aware of generated code is supported check name conflict of all files after getAllFiles(truly: Boolean) is supported ","description":"Tracer is not perfect, but can be optimized much if the IDE and Kotlin plugin cooperate.\n1, Too many hints when you input _X. in a big project. (after the visibility, of functions with context receivers, is fixed -\u0026gt; new generated tracer property would replace the receiver with context receiver. Then there wouldn\u0026rsquo;t be redundant hints.)\n2, names may change with the structure.\n-\u0026gt; 新的变更名字模式，实际值为 contractedName_packageName(_levelTag)_containerName_propertyName。 根据当前的实际需要来显示。且后台给每个 context 分配出一套提示\n3, 针对 property 重写问题，如"},{"id":8,"href":"/TracerTutorial/extensions/","title":"Extensions","parent":"","content":"","description":""},{"id":9,"href":"/TracerTutorial/myWords/","title":"My words","parent":"","content":"This tutorial is very clear and worth learned by most authoritative IT tutorials, which is mainly because of bosses\u0026rsquo; overlooking rather than myself. Below is my advice.\nLet better developers write tutorials. Most tutorial code I\u0026rsquo;ve ever seen are half redundant. Embed short videos with speeding up, effect display, and concise hints instead of all voluminous texts. Inspire them by relating their salaries to feedbacks. Update with projects or applications. Code in this project is probably the globally best at present for its functionality, creativity, difficulty, structure, efficiency, and beauty. Wish you could learn from it！Note that it is too special and complicated to be a ksp development sample.\nIn addition to Tracer, I have two other halfway done works and am waiting for some company to help make IDE plugins. I have sent resumes to common top internet companies, but those limited resume sizes are too small and they didn\u0026rsquo;t give me opportunities to display.\nAt last, if you are familiar with IT, feel hard to learn Kotlin and love Java or Go more, your logic ability mustn\u0026rsquo;t be well enough for you to engage in IT. If so, do something you love and must excel at. I have no offensive intention, just meaning everyone has his strengths and weaknesses, and every job has its threshold.\n","description":"This tutorial is very clear and worth learned by most authoritative IT tutorials, which is mainly because of bosses\u0026rsquo; overlooking rather than myself. Below is my advice.\nLet better developers write tutorials. Most tutorial code I\u0026rsquo;ve ever seen are half redundant. Embed short videos with speeding up, effect display, and concise hints instead of all voluminous texts. Inspire them by relating their salaries to feedbacks. Update with projects or applications. Code in this project is probably the globally best at present for its functionality, creativity, difficulty, structure, efficiency, and beauty."},{"id":10,"href":"/TracerTutorial/","title":"","parent":"","content":"With Kotlin-JVM and KSP, Tracer generates extensional properties orienting to interior traceable elements, which realizes dependency injection with little configuration. Your browser doesn't support embedded videos, but don't worry, you can download it and watch it with your favorite video player! ","description":"With Kotlin-JVM and KSP, Tracer generates extensional properties orienting to interior traceable elements, which realizes dependency injection with little configuration. Your browser doesn't support embedded videos, but don't worry, you can download it and watch it with your favorite video player! "},{"id":11,"href":"/TracerTutorial/tags/","title":"Tags","parent":"","content":"","description":""}]