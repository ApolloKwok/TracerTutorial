[{"id":0,"href":"/TracerTutorial/usage/core/","title":"Core","parent":"Usage","content":" Root Each class annotated with Tracer.Root is considered as the trace start point. Its module-visible elements would be traced as below. Your browser doesn't support embedded videos, but don't worry, you can download it and watch it with your favorite video player! Nodes Now we add one bedroom and some inner objects as below. If each bedroom is explored from House, there would be two windows, two beds and \u0026hellip; everywhere. This could be solved by annotating Bedroom with Tracer.Nodes(House::class), which makes its inner elements shared and connect with those inside House but outside Bedroom. If you are in Living room and need master bedroom\u0026rsquo;s Quilt, reference it like _Bedroom_House_masterBedroom._Quilt.\nYour browser doesn't support embedded videos, but don't worry, you can download it and watch it with your favorite video player! ","description":"Root Each class annotated with Tracer.Root is considered as the trace start point. Its module-visible elements would be traced as below. Your browser doesn't support embedded videos, but don't worry, you can download it and watch it with your favorite video player! Nodes Now we add one bedroom and some inner objects as below. If each bedroom is explored from House, there would be two windows, two beds and \u0026hellip; everywhere."},{"id":1,"href":"/TracerTutorial/preview/","title":"Preview","parent":"","content":" There aren\u0026rsquo;t any configuration else. Your browser doesn\u0026rsquo;t support embedded videos, but don\u0026rsquo;t worry, you can download it and watch it with your favorite video player! ","description":" There aren\u0026rsquo;t any configuration else. Your browser doesn\u0026rsquo;t support embedded videos, but don\u0026rsquo;t worry, you can download it and watch it with your favorite video player! "},{"id":2,"href":"/TracerTutorial/extensions/traditional-android/","title":"Traditional android","parent":"Extensions","content":"See github repo if you need.\n","description":"See github repo if you need."},{"id":3,"href":"/TracerTutorial/usage/naming-analysis/","title":"Property naming analysis","parent":"Usage","content":" __: beginning with double _ tells it\u0026rsquo;s from outside like getting WifiRouter as below.\n˚: as shown in the image above, ˚House means that House is the nearest owner annotated with Tracer.Root or Tracer.Nodes of that WifiRouter. suspend () -\u0026gt; Pair\u0026lt;Pillow, Pillow\u0026gt;? would be converted to ⍒❨❩-›Pair‹Pillow，Pillow›？. (suspend) lambda, generic type and nullability are all supported. Unfortunately, android forbids most original common symbols in property names, making me choose these substitutes ⍒ ❨ ❩ -› ‹ › ？. ↑ ↓. ↑ represent in, ↓ represent out. Array\u0026lt;in House\u0026gt; is converted to Array‹↑House› As shown below, there are 3 houses inside X, making their corresponding generated property names different. nullability suspend and variance are omitted in type equality comparison.\nGeneric type with a single bound Generic type with multiple bounds ","description":"__: beginning with double _ tells it\u0026rsquo;s from outside like getting WifiRouter as below.\n˚: as shown in the image above, ˚House means that House is the nearest owner annotated with Tracer.Root or Tracer.Nodes of that WifiRouter. suspend () -\u0026gt; Pair\u0026lt;Pillow, Pillow\u0026gt;? would be converted to ⍒❨❩-›Pair‹Pillow，Pillow›？. (suspend) lambda, generic type and nullability are all supported. Unfortunately, android forbids most original common symbols in property names, making me choose these substitutes ⍒ ❨ ❩ -› ‹ › ？."},{"id":4,"href":"/TracerTutorial/setup/","title":"Setup","parent":"","content":"Configure your build.gradle as below.\nAdd the ksp plugin plugins{ // Assuming your kotlin version is `1.7.21`, here uses the latest ksp plugin version beginning // with `1.7.21` (\u0026#39;1.7.21-1.0.8\u0026#39;). id \u0026#39;com.google.devtools.ksp\u0026#39; version \u0026#39;1.7.21-1.0.8\u0026#39; } Add source sets Skip this step if your ksp plugin version is \u0026lsquo;1.8.0-1.0.9\u0026rsquo; or higher.\nThis part is different if you are using IntelliJ IDEA and KSP in a Gradle plugin. (See ksp quickstart)\n// Omissible if your ksp plugin version is \u0026#39;1.8.0-1.0.9\u0026#39; or higher. kotlin.sourceSets { main.kotlin.srcDirs += \u0026#34;$buildDir/generated/ksp/main/kotlin\u0026#34; test.kotlin.srcDirs += \u0026#34;$buildDir/generated/ksp/test/kotlin\u0026#34; } Configure tracer Add this part directly, rather than insert messily.\n//region tracer // options ksp{ // arg(\u0026#34;tracer.allInternallyGenerated\u0026#34;, \u0026#34;\u0026#34;) // arg(\u0026#34;tracer.propertiesFullName\u0026#34;, \u0026#34;\u0026#34;) } tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach { kotlinOptions.freeCompilerArgs += \u0026#39;-Xcontext-receivers\u0026#39; } dependencies { // Keep this version latest with the prefix lower than your kotlin version(inclusive). ksp \u0026#39;io.github.apollokwok:tracer-common-compiler:1.7.20-1.1.0\u0026#39; // Keep this version latest but lower than the version above(inclusive). implementation \u0026#39;io.github.apollokwok:tracer-common-annotations:1.7.20-1.1.0\u0026#39; } //endregion ","description":"Configure your build.gradle as below.\nAdd the ksp plugin plugins{ // Assuming your kotlin version is `1.7.21`, here uses the latest ksp plugin version beginning // with `1.7.21` (\u0026#39;1.7.21-1.0.8\u0026#39;). id \u0026#39;com.google.devtools.ksp\u0026#39; version \u0026#39;1.7.21-1.0.8\u0026#39; } Add source sets Skip this step if your ksp plugin version is \u0026lsquo;1.8.0-1.0.9\u0026rsquo; or higher.\nThis part is different if you are using IntelliJ IDEA and KSP in a Gradle plugin. (See ksp quickstart)\n// Omissible if your ksp plugin version is \u0026#39;1."},{"id":5,"href":"/TracerTutorial/usage/details/","title":"Details","parent":"Usage","content":" Wildcard * would be converted to its bound, and with covariance if needed, like from List\u0026lt;*\u0026gt; to List‹Any？› and from Array\u0026lt;*\u0026gt; to Array‹↓Any？›. Type aliases are always converted to its actual types. Partial super types are traceable. including src klass 截止到 foreign module or Java\\\n截止探索 element 的条件\ntags.AllInternal\ntags.propertiesFullName\nOmit 的用法\nTips 的用法 支持 var\\\n","description":"Wildcard * would be converted to its bound, and with covariance if needed, like from List\u0026lt;*\u0026gt; to List‹Any？› and from Array\u0026lt;*\u0026gt; to Array‹↓Any？›. Type aliases are always converted to its actual types. Partial super types are traceable. including src klass 截止到 foreign module or Java\\\n截止探索 element 的条件\ntags.AllInternal\ntags.propertiesFullName\nOmit 的用法\nTips 的用法 支持 var\\"},{"id":6,"href":"/TracerTutorial/usage/","title":"Usage","parent":"","content":"","description":""},{"id":7,"href":"/TracerTutorial/usage/notes/","title":"Notes","parent":"Usage","content":"Unexplained norms below must be confusing to tyros. Just obey them!\nAlways inject with prival val x get() = ....\nKotlin Native and Kotlin JS are not supported. Because they lack context receiver which is essential in this tool.\nSyntax T \u0026amp; Any is not allowed until ksp version 1.8.0-1.0.9. In old versions, you could annotate those traceable properties or super types with @Tracer.Omit to omit them in the trace.\nTracer is compatible with ksp 1.7.0-1.0.6 at least. Although mostly it works well with ksp, you\u0026rsquo;d better try to make your ksp plugin in a high stable version, since ksp api is not stable and many bugs are fixed every version.\nJava files are forbidden to use Tracer, because I don\u0026rsquo;t want to spend time analyzing those outdated things. But it\u0026rsquo;s absolutely safe to reference java classes and functions in kotlin files with tracer.\n*, Few generated types fail code inspection, mostly because of the imperfect authoritative type inference system. Find their corresponding source properties or super types, then use another type or annotate them with`@Tracer.Omitted`. e.g.: todo\n*, 如果 super abstract class 和 self 均有 Root /Nodes 标记，那么 super abstract class 中最好不要 override self\n4, 解释 common type 的标准\n5, alias type 中带 * 可能会因为 multi-bounds 导致结果不准确\n9, 对于带泛型 / open / abstract class, 因为复用率高，不会从 property type trace, 对于会被多次构造的 class，应让 programmer 尽量少去探索次内部的东西\n","description":"Unexplained norms below must be confusing to tyros. Just obey them!\nAlways inject with prival val x get() = ....\nKotlin Native and Kotlin JS are not supported. Because they lack context receiver which is essential in this tool.\nSyntax T \u0026amp; Any is not allowed until ksp version 1.8.0-1.0.9. In old versions, you could annotate those traceable properties or super types with @Tracer.Omit to omit them in the trace."},{"id":8,"href":"/TracerTutorial/optimization/","title":"Optimization","parent":"","content":"","description":""},{"id":9,"href":"/TracerTutorial/expectedOptimization/","title":"Expected optimization","parent":"","content":"Tracer is not perfect, but can be optimized much if the IDE and Kotlin plugin cooperate.\n1, Too many hints when you input _X. in a big project. (after the visibility, of functions with context receivers, is fixed -\u0026gt; new generated tracer property would replace the receiver with context receiver. Then there wouldn\u0026rsquo;t be redundant hints.)\n2, names may change with the structure.\n-\u0026gt; 新的变更名字模式，实际值为 contractedName_packageName(_levelTag)_containerName_propertyName。 根据当前的实际需要来显示。且后台给每个 context 分配出一套提示\n3, 针对 property 重写问题，如\n@Tracer.Root class X : XTracer{ abstract val j: J } @Tracer.Root class XImpl : X(), XImplTracer{ override val j: J = J() } 结合2，如果有重写，则父类相应的 val XTracer.j inline get() = ... 不对 XImplTracer 可见\n4, Implement tracer interfaces automatically.\n5, Override and solve the conflict automatically.\n","description":"Tracer is not perfect, but can be optimized much if the IDE and Kotlin plugin cooperate.\n1, Too many hints when you input _X. in a big project. (after the visibility, of functions with context receivers, is fixed -\u0026gt; new generated tracer property would replace the receiver with context receiver. Then there wouldn\u0026rsquo;t be redundant hints.)\n2, names may change with the structure.\n-\u0026gt; 新的变更名字模式，实际值为 contractedName_packageName(_levelTag)_containerName_propertyName。 根据当前的实际需要来显示。且后台给每个 context 分配出一套提示\n3, 针对 property 重写问题，如"},{"id":10,"href":"/TracerTutorial/extensions/","title":"Extensions","parent":"","content":"","description":""},{"id":11,"href":"/TracerTutorial/myWords/","title":"My words","parent":"","content":"Code in this project is probably the globally best at present for its functionality, creativity, difficulty, structure, efficiency, concision, and beauty. Wish you could learn from it！\nThis tool would help manage memory well assuming Kotlin is without GC, because most nodes only need to manage its own element memories or transfer them to its owner. In the near future, programming languages would be unified and the whole IT development structure would be rebuilt.\nIn addition to this, I have two other halfway done works and am waiting for some company to help make IDE plugins. I have sent resumes to common top internet companies, but those limited resume sizes are too small and they didn\u0026rsquo;t give me opportunities to display.\nAt last, if you are familiar with IT, feel hard to learn Kotlin and love Java or Go more, your logic ability mustn\u0026rsquo;t be well enough for you to engage in IT. If so, do something you love and must excel at. I have no offensive intention, just meaning everyone has his strengths and weaknesses, and every job has its threshold.\n","description":"Code in this project is probably the globally best at present for its functionality, creativity, difficulty, structure, efficiency, concision, and beauty. Wish you could learn from it！\nThis tool would help manage memory well assuming Kotlin is without GC, because most nodes only need to manage its own element memories or transfer them to its owner. In the near future, programming languages would be unified and the whole IT development structure would be rebuilt."},{"id":12,"href":"/TracerTutorial/","title":"","parent":"","content":"Tracer generates extensional properties orienting to inner traceable elements, which realizes dependency injection with little configuration.\n","description":"Tracer generates extensional properties orienting to inner traceable elements, which realizes dependency injection with little configuration."},{"id":13,"href":"/TracerTutorial/tags/","title":"Tags","parent":"","content":"","description":""}]